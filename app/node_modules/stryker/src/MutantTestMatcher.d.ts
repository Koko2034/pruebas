import { RunResult } from 'stryker-api/test_runner';
import { StrykerOptions, File } from 'stryker-api/core';
import { Mutant } from 'stryker-api/mutant';
import TestableMutant from './TestableMutant';
import StrictReporter from './reporters/StrictReporter';
import { StatementMapDictionary } from './transpiler/CoverageInstrumenterTranspiler';
export default class MutantTestMatcher {
    private mutants;
    private files;
    private initialRunResult;
    private statementMaps;
    private options;
    private reporter;
    private readonly log;
    constructor(mutants: Mutant[], files: File[], initialRunResult: RunResult, statementMaps: StatementMapDictionary, options: StrykerOptions, reporter: StrictReporter);
    private readonly baseline;
    matchWithMutants(): TestableMutant[];
    enrichWithCoveredTests(testableMutant: TestableMutant): void;
    private isCoveredByBaseline(filename, statementId);
    private isCoveredByTest(testId, filename, statementId);
    private createTestableMutants();
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param testableMutant The mutant.
     * @returns The MatchedMutant
     */
    private mapMutantOnMatchedMutant(testableMutant);
    /**
     * Finds the smallest statement that covers a mutant.
     * @param mutant The mutant.
     * @param statementMap of the covering file.
     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.
     */
    private findSmallestCoveringStatement(mutant, statementMap);
    /**
     * Indicates whether a statement is the smallest statement of the two statements provided.
     * @param originalLocation The area which may cover a bigger area than the newLocation.
     * @param newLocation The area which may cover a smaller area than the originalLocation.
     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.
     */
    private isNewSmallestStatement(originalLocation, newLocation);
    /**
     * Indicates whether a statement covers a mutant.
     * @param mutantLocation The location of the mutant.
     * @param statementLocation The location of the statement.
     * @returns true if the statment covers the mutant.
     */
    private statementCoversMutant(mutantLocation, statementLocation);
    private findCoverageCollectionForTest(testId);
    private isCoveragePerTestResult(coverage);
}
