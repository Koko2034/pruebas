"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var os_1 = require("os");
var test_runner_1 = require("stryker-api/test_runner");
var TranspilerFacade_1 = require("../transpiler/TranspilerFacade");
var log4js_1 = require("log4js");
var Sandbox_1 = require("../Sandbox");
var CoverageInstrumenterTranspiler_1 = require("../transpiler/CoverageInstrumenterTranspiler");
// The initial run might take a while.
// For example: angular-bootstrap takes up to 45 seconds.
// Lets take 5 minutes just to be sure
var INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;
var InitialTestExecutor = /** @class */ (function () {
    function InitialTestExecutor(options, files, testFramework, timer) {
        this.options = options;
        this.files = files;
        this.testFramework = testFramework;
        this.timer = timer;
        this.log = log4js_1.getLogger(InitialTestExecutor.name);
    }
    InitialTestExecutor.prototype.run = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.files.length > 0)) return [3 /*break*/, 2];
                        this.log.info("Starting initial test run. This may take a while.");
                        return [4 /*yield*/, this.initialRunInSandbox()];
                    case 1:
                        result = _a.sent();
                        this.validateResult(result.runResult);
                        return [2 /*return*/, result];
                    case 2:
                        this.log.info("No files have been found. Aborting initial test run.");
                        return [2 /*return*/, this.createDryRunResult()];
                }
            });
        });
    };
    InitialTestExecutor.prototype.initialRunInSandbox = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var coverageInstrumenterTranspiler, transpilerFacade, transpileResult, sandbox_1, runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coverageInstrumenterTranspiler = this.createCoverageInstrumenterTranspiler();
                        transpilerFacade = this.createTranspilerFacade(coverageInstrumenterTranspiler);
                        return [4 /*yield*/, transpilerFacade.transpile(this.files)];
                    case 1:
                        transpileResult = _a.sent();
                        if (!transpileResult.error) return [3 /*break*/, 2];
                        throw new Error("Could not transpile input files: " + transpileResult.error);
                    case 2:
                        this.logTranspileResult(transpileResult);
                        return [4 /*yield*/, Sandbox_1.default.create(this.options, 0, transpileResult.outputFiles, this.testFramework)];
                    case 3:
                        sandbox_1 = _a.sent();
                        return [4 /*yield*/, sandbox_1.run(INITIAL_RUN_TIMEOUT)];
                    case 4:
                        runResult = _a.sent();
                        return [4 /*yield*/, sandbox_1.dispose()];
                    case 5:
                        _a.sent();
                        return [2 /*return*/, { runResult: runResult, transpiledFiles: transpileResult.outputFiles, statementMaps: coverageInstrumenterTranspiler.statementMapsPerFile }];
                }
            });
        });
    };
    InitialTestExecutor.prototype.validateResult = function (runResult) {
        switch (runResult.status) {
            case test_runner_1.RunStatus.Complete:
                var failedTests = this.filterOutFailedTests(runResult);
                if (failedTests.length) {
                    this.logFailedTestsInInitialRun(failedTests);
                    throw new Error('There were failed tests in the initial test run.');
                }
                if (runResult.tests.length === 0) {
                    this.log.warn('No tests were executed. Stryker will exit prematurely. Please check your configuration.');
                    return;
                }
                else {
                    this.logInitialTestRunSucceeded(runResult.tests);
                    return;
                }
            case test_runner_1.RunStatus.Error:
                this.logErrorsInInitialRun(runResult);
                break;
            case test_runner_1.RunStatus.Timeout:
                this.logTimeoutInitialRun(runResult);
                break;
        }
        throw new Error('Something went wrong in the initial test run');
    };
    InitialTestExecutor.prototype.createDryRunResult = function () {
        return {
            runResult: {
                status: test_runner_1.RunStatus.Complete,
                tests: [],
                errorMessages: []
            },
            transpiledFiles: [],
            statementMaps: Object.create(null)
        };
    };
    /**
     * Creates a facade for the transpile pipeline.
     * Also includes the coverage instrumenter transpiler,
     * which is used to instrument for code coverage when needed.
     */
    InitialTestExecutor.prototype.createTranspilerFacade = function (coverageInstrumenterTranspiler) {
        var transpilerSettings = { config: this.options, keepSourceMaps: true };
        return new TranspilerFacade_1.default(transpilerSettings, {
            name: CoverageInstrumenterTranspiler_1.default.name,
            transpiler: coverageInstrumenterTranspiler
        });
    };
    InitialTestExecutor.prototype.createCoverageInstrumenterTranspiler = function () {
        return new CoverageInstrumenterTranspiler_1.default({ keepSourceMaps: true, config: this.options }, this.testFramework);
    };
    InitialTestExecutor.prototype.logTranspileResult = function (transpileResult) {
        if (this.options.transpilers.length && this.log.isDebugEnabled()) {
            this.log.debug("Transpiled files in order:" + os_1.EOL + transpileResult.outputFiles.map(function (f) { return f.name + " (included: " + f.included + ")"; }).join(os_1.EOL));
        }
    };
    InitialTestExecutor.prototype.filterOutFailedTests = function (runResult) {
        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });
    };
    InitialTestExecutor.prototype.logInitialTestRunSucceeded = function (tests) {
        this.log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());
    };
    InitialTestExecutor.prototype.logFailedTestsInInitialRun = function (failedTests) {
        var message = 'One or more tests failed in the initial test run:';
        failedTests.forEach(function (test) {
            message += os_1.EOL + "\t" + test.name;
            if (test.failureMessages && test.failureMessages.length) {
                message += os_1.EOL + "\t\t" + test.failureMessages.join(os_1.EOL + "\t\t");
            }
        });
        this.log.error(message);
    };
    InitialTestExecutor.prototype.logErrorsInInitialRun = function (runResult) {
        var message = 'One or more tests resulted in an error:';
        if (runResult.errorMessages && runResult.errorMessages.length) {
            runResult.errorMessages.forEach(function (error) { return message += os_1.EOL + "\t" + error; });
        }
        this.log.error(message);
    };
    InitialTestExecutor.prototype.logTimeoutInitialRun = function (runResult) {
        var message = 'Initial test run timed out! Ran following tests before timeout:';
        runResult.tests.forEach(function (test) { return message += os_1.EOL + "\t" + test.name + " (" + test_runner_1.TestStatus[test.status] + ")"; });
        this.log.error(message);
    };
    return InitialTestExecutor;
}());
exports.default = InitialTestExecutor;
//# sourceMappingURL=InitialTestExecutor.js.map