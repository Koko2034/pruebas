"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var transpile_1 = require("stryker-api/transpile");
var NamedTranspiler = /** @class */ (function () {
    function NamedTranspiler(name, transpiler) {
        this.name = name;
        this.transpiler = transpiler;
    }
    return NamedTranspiler;
}());
var TranspilerFacade = /** @class */ (function () {
    function TranspilerFacade(options, additionalTranspiler) {
        this.innerTranspilers = options.config.transpilers
            .map(function (transpilerName) { return new NamedTranspiler(transpilerName, transpile_1.TranspilerFactory.instance().create(transpilerName, options)); });
        if (additionalTranspiler) {
            this.innerTranspilers.push(new NamedTranspiler(additionalTranspiler.name, additionalTranspiler.transpiler));
        }
    }
    TranspilerFacade.prototype.transpile = function (files) {
        return this.performTranspileChain(this.createPassThruTranspileResult(files));
    };
    TranspilerFacade.prototype.getMappedLocation = function (sourceFileLocation) {
        return this.performMappedLocationChain(sourceFileLocation);
    };
    TranspilerFacade.prototype.performMappedLocationChain = function (sourceFileLocation, remainingChain) {
        if (remainingChain === void 0) { remainingChain = this.innerTranspilers.slice(); }
        var next = remainingChain.shift();
        if (next) {
            return this.performMappedLocationChain(next.transpiler.getMappedLocation(sourceFileLocation), remainingChain);
        }
        else {
            return sourceFileLocation;
        }
    };
    TranspilerFacade.prototype.performTranspileChain = function (currentResult, remainingChain) {
        if (remainingChain === void 0) { remainingChain = this.innerTranspilers.slice(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var next, nextResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        next = remainingChain.shift();
                        if (!next) return [3 /*break*/, 2];
                        return [4 /*yield*/, next.transpiler.transpile(currentResult.outputFiles)];
                    case 1:
                        nextResult = _a.sent();
                        if (nextResult.error) {
                            nextResult.error = "Execute " + next.name + ": " + nextResult.error;
                            return [2 /*return*/, nextResult];
                        }
                        else {
                            return [2 /*return*/, this.performTranspileChain(nextResult, remainingChain)];
                        }
                        return [3 /*break*/, 3];
                    case 2: return [2 /*return*/, currentResult];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TranspilerFacade.prototype.createPassThruTranspileResult = function (input) {
        return {
            error: null,
            outputFiles: input
        };
    };
    return TranspilerFacade;
}());
exports.default = TranspilerFacade;
//# sourceMappingURL=TranspilerFacade.js.map