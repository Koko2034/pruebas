"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var TranspilerFacade_1 = require("./TranspilerFacade");
var core_1 = require("stryker-api/core");
var log4js_1 = require("log4js");
var ChildProcessProxy_1 = require("../child-proxy/ChildProcessProxy");
var MutantTranspiler = /** @class */ (function () {
    /**
     * Creates the mutant transpiler in a child process if one is defined.
     * Otherwise will just forward input as output in same process.
     * @param config The Stryker config
     */
    function MutantTranspiler(config) {
        var transpilerOptions = { config: config, keepSourceMaps: false };
        if (config.transpilers.length) {
            this.transpilerChildProcess = ChildProcessProxy_1.default.create(require.resolve('./TranspilerFacade'), config.logLevel, config.plugins, TranspilerFacade_1.default, transpilerOptions);
            this.proxy = this.transpilerChildProcess.proxy;
        }
        else {
            var transpiler_1 = new TranspilerFacade_1.default(transpilerOptions);
            this.proxy = {
                transpile: function (files) {
                    return Promise.resolve(transpiler_1.transpile(files));
                },
                getMappedLocation: function (sourceFileLocation) {
                    return Promise.resolve(transpiler_1.getMappedLocation(sourceFileLocation));
                }
            };
        }
        this.log = log4js_1.getLogger(MutantTranspiler.name);
    }
    MutantTranspiler.prototype.initialize = function (files) {
        return this.proxy.transpile(files);
    };
    MutantTranspiler.prototype.transpileMutants = function (allMutants) {
        var _this = this;
        var mutants = allMutants.slice();
        return new rxjs_1.Observable(function (observer) {
            var nextMutant = function () {
                var mutant = mutants.shift();
                if (mutant) {
                    _this.transpileMutant(mutant)
                        .then(function (transpileResult) { return observer.next({ mutant: mutant, transpileResult: transpileResult }); })
                        .then(nextMutant)
                        .catch(function (error) { return observer.error(error); });
                }
                else {
                    observer.complete();
                }
            };
            nextMutant();
        });
    };
    MutantTranspiler.prototype.dispose = function () {
        if (this.transpilerChildProcess) {
            this.transpilerChildProcess.dispose();
        }
    };
    MutantTranspiler.prototype.transpileMutant = function (mutant) {
        var filesToTranspile = [];
        if (this.currentMutatedFile && this.currentMutatedFile.file.name !== mutant.fileName) {
            filesToTranspile.push(this.currentMutatedFile.file);
        }
        this.currentMutatedFile = mutant.sourceFile;
        var mutatedFile = {
            name: mutant.fileName,
            content: mutant.mutatedCode,
            kind: core_1.FileKind.Text,
            mutated: this.currentMutatedFile.file.mutated,
            transpiled: this.currentMutatedFile.file.transpiled,
            included: mutant.included
        };
        filesToTranspile.push(mutatedFile);
        return this.proxy.transpile(filesToTranspile);
    };
    return MutantTranspiler;
}());
exports.default = MutantTranspiler;
//# sourceMappingURL=MutantTranspiler.js.map