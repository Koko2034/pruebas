"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var os = require("os");
var path = require("path");
var fs = require("mz/fs");
var _ = require("lodash");
var log4js_1 = require("log4js");
var core_1 = require("stryker-api/core");
var fileUtils_1 = require("./utils/fileUtils");
var DEFAULT_INPUT_FILE_PROPERTIES = { mutated: false, included: true, transpiled: true };
function testFileToReportFile(textFile) {
    return {
        path: textFile.name,
        content: textFile.content
    };
}
var InputFileResolver = /** @class */ (function () {
    function InputFileResolver(mutate, allFileExpressions, reporter) {
        this.reporter = reporter;
        this.log = log4js_1.getLogger(InputFileResolver.name);
        this.validateFileDescriptor(allFileExpressions);
        this.validateMutationArray(mutate);
        this.mutateResolver = PatternResolver.parse(mutate || []);
        this.inputFileResolver = PatternResolver.parse(allFileExpressions);
    }
    InputFileResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, inputFileDescriptors, mutateFiles, files;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([this.inputFileResolver.resolve(), this.mutateResolver.resolve()])];
                    case 1:
                        _a = _b.sent(), inputFileDescriptors = _a[0], mutateFiles = _a[1];
                        return [4 /*yield*/, this.readFiles(inputFileDescriptors)];
                    case 2:
                        files = _b.sent();
                        this.markAdditionalFilesToMutate(files, mutateFiles.map(function (m) { return m.name; }));
                        this.logFilesToMutate(files);
                        this.reportAllSourceFilesRead(files);
                        return [2 /*return*/, files];
                }
            });
        });
    };
    InputFileResolver.prototype.validateFileDescriptor = function (maybeInputFileDescriptors) {
        maybeInputFileDescriptors.forEach(function (maybeInputFileDescriptor) {
            if (_.isObject(maybeInputFileDescriptor)) {
                if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') === -1) {
                    throw Error("File descriptor " + JSON.stringify(maybeInputFileDescriptor) + " is missing mandatory property 'pattern'.");
                }
                else {
                    maybeInputFileDescriptor = maybeInputFileDescriptor;
                    if (fileUtils_1.isOnlineFile(maybeInputFileDescriptor.pattern) && maybeInputFileDescriptor.mutated) {
                        throw new Error("Cannot mutate web url \"" + maybeInputFileDescriptor.pattern + "\".");
                    }
                }
            }
        });
    };
    InputFileResolver.prototype.validateMutationArray = function (mutationArray) {
        if (mutationArray) {
            mutationArray.forEach(function (mutation) {
                if (fileUtils_1.isOnlineFile(mutation)) {
                    throw new Error("Cannot mutate web url \"" + mutation + "\".");
                }
            });
        }
    };
    InputFileResolver.prototype.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {
        var errors = [];
        additionalMutateFiles.forEach(function (mutateFile) {
            if (!allInputFiles.filter(function (inputFile) { return inputFile.name === mutateFile; }).length) {
                errors.push("Could not find mutate file \"" + mutateFile + "\" in list of files.");
            }
        });
        if (errors.length > 0) {
            throw new Error(errors.join(' '));
        }
        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.name; }) || file.mutated; });
    };
    InputFileResolver.prototype.logFilesToMutate = function (allInputFiles) {
        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });
        if (mutateFiles.length) {
            this.log.info("Found " + mutateFiles.length + " of " + allInputFiles.length + " file(s) to be mutated.");
        }
        else {
            this.log.warn("No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.");
        }
        if (this.log.isDebugEnabled) {
            this.log.debug('All input files in order:%s', allInputFiles.map(function (file) { return os.EOL + "\t" + file.name + " (included: " + file.included + ", mutated: " + file.mutated + ")"; }));
        }
    };
    InputFileResolver.prototype.reportAllSourceFilesRead = function (allFiles) {
        this.reporter.onAllSourceFilesRead(this.filterTextFiles(allFiles).map(testFileToReportFile));
    };
    InputFileResolver.prototype.reportSourceFilesRead = function (textFile) {
        this.reporter.onSourceFileRead(testFileToReportFile(textFile));
    };
    InputFileResolver.prototype.filterTextFiles = function (files) {
        return files.filter(function (file) { return file.kind === core_1.FileKind.Text; });
    };
    InputFileResolver.prototype.readFiles = function (inputFileDescriptors) {
        var _this = this;
        return Promise.all(inputFileDescriptors.map(function (file) { return _this.readInputFile(file); }));
    };
    InputFileResolver.prototype.readInputFile = function (descriptor) {
        var _this = this;
        switch (descriptor.kind) {
            case core_1.FileKind.Web:
                var web = { kind: core_1.FileKind.Web };
                return Promise.resolve(Object.assign({}, descriptor, web));
            case core_1.FileKind.Text:
                return this.readLocalFile(descriptor, descriptor.kind).then(function (textFile) {
                    _this.reportSourceFilesRead(textFile);
                    return textFile;
                });
            default:
                return this.readLocalFile(descriptor, descriptor.kind);
        }
    };
    InputFileResolver.prototype.readLocalFile = function (descriptor, kind) {
        return this.readInputFileContent(descriptor.name, kind).then(function (content) { return ({
            name: descriptor.name,
            kind: descriptor.kind,
            content: content,
            included: descriptor.included,
            mutated: descriptor.mutated,
            transpiled: descriptor.transpiled
        }); });
    };
    InputFileResolver.prototype.readInputFileContent = function (fileName, kind) {
        if (kind === core_1.FileKind.Binary) {
            return fs.readFile(fileName);
        }
        else {
            return fs.readFile(fileName, 'utf8');
        }
    };
    return InputFileResolver;
}());
exports.default = InputFileResolver;
var PatternResolver = /** @class */ (function () {
    function PatternResolver(descriptor, previous) {
        this.previous = previous;
        this.log = log4js_1.getLogger(InputFileResolver.name);
        this.ignore = false;
        if (typeof descriptor === 'string') {
            this.descriptor = Object.assign({ pattern: descriptor }, DEFAULT_INPUT_FILE_PROPERTIES);
            this.ignore = descriptor.indexOf('!') === 0;
            if (this.ignore) {
                this.descriptor.pattern = descriptor.substring(1);
            }
        }
        else {
            this.descriptor = descriptor;
        }
    }
    PatternResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var globbingTask, results, previousFiles_1, currentFiles_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.ignore && !this.previous)) return [3 /*break*/, 1];
                        return [2 /*return*/, Promise.resolve([])];
                    case 1:
                        globbingTask = this.resolveGlobbingExpression(this.descriptor.pattern)
                            .then(function (filePaths) { return filePaths.map(function (filePath) { return _this.createInputFile(filePath); }); });
                        if (!this.previous) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all([this.previous.resolve(), globbingTask])];
                    case 2:
                        results = _a.sent();
                        previousFiles_1 = results[0];
                        currentFiles_1 = results[1];
                        // If this expression started with a '!', exclude current files
                        if (this.ignore) {
                            return [2 /*return*/, previousFiles_1.filter(function (previousFile) { return currentFiles_1.every(function (currentFile) { return previousFile.name !== currentFile.name; }); })];
                        }
                        else {
                            // Only add files which were not already added
                            return [2 /*return*/, previousFiles_1.concat(currentFiles_1.filter(function (currentFile) { return !previousFiles_1.some(function (file) { return file.name === currentFile.name; }); }))];
                        }
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, globbingTask];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PatternResolver.empty = function () {
        var emptyResolver = new PatternResolver('');
        emptyResolver.ignore = true;
        return emptyResolver;
    };
    PatternResolver.parse = function (inputFileExpressions) {
        var expressions = inputFileExpressions.map(function (i) { return i; }); // work on a copy as we're changing the array state
        var current = PatternResolver.empty();
        var expression = expressions.shift();
        while (expression) {
            current = new PatternResolver(expression, current);
            expression = expressions.shift();
        }
        return current;
    };
    PatternResolver.prototype.resolveGlobbingExpression = function (pattern) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var files;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!fileUtils_1.isOnlineFile(pattern)) return [3 /*break*/, 1];
                        return [2 /*return*/, Promise.resolve([pattern])];
                    case 1: return [4 /*yield*/, fileUtils_1.glob(pattern)];
                    case 2:
                        files = _a.sent();
                        if (files.length === 0) {
                            this.reportEmptyGlobbingExpression(pattern);
                        }
                        return [2 /*return*/, files.map(function (f) { return path.resolve(f); })];
                }
            });
        });
    };
    PatternResolver.prototype.reportEmptyGlobbingExpression = function (expression) {
        this.log.warn("Globbing expression \"" + expression + "\" did not result in any files.");
    };
    PatternResolver.prototype.createInputFile = function (name) {
        var inputFile = _.assign({ name: name, kind: fileUtils_1.determineFileKind(name) }, DEFAULT_INPUT_FILE_PROPERTIES, this.descriptor);
        delete inputFile['pattern'];
        return inputFile;
    };
    return PatternResolver;
}());
//# sourceMappingURL=InputFileResolver.js.map