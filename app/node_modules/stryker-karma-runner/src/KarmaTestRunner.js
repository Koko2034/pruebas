"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var test_runner_1 = require("stryker-api/test_runner");
var karma = require("karma");
var log4js = require("log4js");
var _ = require("lodash");
var events_1 = require("events");
var rawCoverageReporter = require("./RawCoverageReporter");
var log = log4js.getLogger('KarmaTestRunner');
var FORCED_OPTIONS = (function () {
    var config = {
        // Override browserNoActivityTimeout. Default value 10000 might not enough to send perTest coverage results
        browserNoActivityTimeout: 1000000,
        // Override base, we don't want to original karma baseDir to be interfering with the stryker setup
        basePath: '.',
        // No auto watch, stryker will inform us when we need to test
        autoWatch: false,
        // Don't stop after first run
        singleRun: false,
        // Never detach, always run in this same process (is already a separate process)
        detached: false
    };
    return Object.freeze(config);
})();
var DEFAULT_OPTIONS = Object.freeze({
    browsers: ['PhantomJS'],
    frameworks: ['jasmine'],
});
var KarmaTestRunner = /** @class */ (function (_super) {
    tslib_1.__extends(KarmaTestRunner, _super);
    function KarmaTestRunner(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        var karmaConfig = _this.configureTestRunner(options.strykerOptions['karmaConfig']);
        karmaConfig = _this.configureCoverageIfEnabled(karmaConfig);
        karmaConfig = _this.configureProperties(karmaConfig);
        log.info("using config " + JSON.stringify(karmaConfig));
        _this.server = new karma.Server(karmaConfig, function (exitCode) {
            process.exit(1);
        });
        _this.listenToBrowserStarted();
        _this.listenToRunComplete();
        _this.listenToSpecComplete();
        _this.listenToCoverage();
        _this.listenToBrowserError();
        _this.server.start();
        return _this;
    }
    KarmaTestRunner.prototype.init = function () {
        return this.serverStartedPromise;
    };
    KarmaTestRunner.prototype.run = function () {
        var _this = this;
        this.currentTestResults = [];
        this.currentErrorMessages = [];
        this.currentCoverageReport = undefined;
        this.currentRunResult = {
            disconnected: false,
            error: false,
            exitCode: 0,
            failed: 0,
            success: 0
        };
        return this.runServer().then(function () { return _this.collectRunResult(); });
    };
    // Don't use dispose() to stop karma (using karma.stopper.stop)
    // It only works when in `detached` mode, as specified here: http://karma-runner.github.io/1.0/config/configuration-file.html
    KarmaTestRunner.prototype.listenToBrowserStarted = function () {
        var _this = this;
        this.serverStartedPromise = new Promise(function (res) { return _this.server.on('browsers_ready', res); });
    };
    KarmaTestRunner.prototype.listenToSpecComplete = function () {
        var _this = this;
        this.server.on('spec_complete', function (browser, spec) {
            var name = spec.suite.join(' ') + " " + spec.description;
            var status = test_runner_1.TestStatus.Failed;
            if (spec.skipped) {
                status = test_runner_1.TestStatus.Skipped;
            }
            else if (spec.success) {
                status = test_runner_1.TestStatus.Success;
            }
            _this.currentTestResults.push({
                name: name,
                status: status,
                timeSpentMs: spec.time,
                failureMessages: spec.log
            });
        });
    };
    KarmaTestRunner.prototype.listenToCoverage = function () {
        var _this = this;
        this.server.on('raw_coverage_complete', function (coverageReport) {
            _this.currentCoverageReport = coverageReport;
        });
    };
    KarmaTestRunner.prototype.listenToRunComplete = function () {
        var _this = this;
        this.server.on('run_complete', function (browsers, runResult) {
            _this.currentRunResult = runResult;
        });
    };
    KarmaTestRunner.prototype.listenToBrowserError = function () {
        var _this = this;
        this.server.on('browser_error', function (browser, error) {
            _this.currentErrorMessages.push(error.toString());
        });
    };
    KarmaTestRunner.prototype.configureProperties = function (karmaConfig) {
        karmaConfig.autoWatch = false;
        karmaConfig.singleRun = false;
        return karmaConfig;
    };
    KarmaTestRunner.prototype.configureCoverageIfEnabled = function (karmaConfig) {
        if (this.options.strykerOptions.coverageAnalysis !== 'off') {
            this.configureCoverageReporters(karmaConfig);
            this.configureCoveragePlugin(karmaConfig);
        }
        return karmaConfig;
    };
    KarmaTestRunner.prototype.configureCoverageReporters = function (karmaConfig) {
        if (!karmaConfig.reporters) {
            karmaConfig.reporters = [];
        }
        karmaConfig.reporters.push('rawCoverage');
    };
    KarmaTestRunner.prototype.configureCoveragePlugin = function (karmaConfig) {
        if (!karmaConfig.plugins) {
            karmaConfig.plugins = ['karma-*'];
        }
        karmaConfig.plugins.push(rawCoverageReporter);
    };
    KarmaTestRunner.prototype.configureTestRunner = function (overrides) {
        // Merge defaults with given
        var karmaConfig = _.assign(_.cloneDeep(DEFAULT_OPTIONS), overrides);
        // Override files
        karmaConfig.files = this.options.files.map(function (file) { return ({ pattern: file.name, included: file.included }); });
        // Override port
        karmaConfig.port = this.options.port;
        this.forceOptions(karmaConfig);
        // Override frameworks
        if (this.options.strykerOptions.testFramework && !(overrides && overrides.frameworks)) {
            karmaConfig.frameworks = [this.options.strykerOptions.testFramework];
        }
        return karmaConfig;
    };
    KarmaTestRunner.prototype.forceOptions = function (karmaConfig) {
        var i;
        for (i in FORCED_OPTIONS) {
            karmaConfig[i] = FORCED_OPTIONS[i];
        }
    };
    KarmaTestRunner.prototype.runServer = function () {
        var _this = this;
        return new Promise(function (resolve) {
            karma.runner.run({ port: _this.options.port }, function (exitCode) {
                log.info('karma run done with ', exitCode);
                resolve();
            });
        });
    };
    KarmaTestRunner.prototype.collectRunResult = function () {
        return {
            tests: this.currentTestResults,
            status: this.collectRunState(),
            coverage: this.currentCoverageReport,
            errorMessages: this.currentErrorMessages
        };
    };
    KarmaTestRunner.prototype.collectRunState = function () {
        if (this.currentRunResult.disconnected) {
            return test_runner_1.RunStatus.Timeout;
        }
        else if (this.currentRunResult.error && this.currentErrorMessages.length > 0) {
            return test_runner_1.RunStatus.Error;
        }
        else {
            return test_runner_1.RunStatus.Complete;
        }
    };
    return KarmaTestRunner;
}(events_1.EventEmitter));
exports.default = KarmaTestRunner;
//# sourceMappingURL=KarmaTestRunner.js.map